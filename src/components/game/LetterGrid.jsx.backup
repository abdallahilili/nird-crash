import { useState, useEffect, useCallback, useRef } from 'react';
import { motion } from 'framer-motion';
import { X, Check, RotateCcw, Zap } from 'lucide-react';
import useGameStore from '../../store/gameStore';

const LetterGrid = ({ gridLetters, onWordFormed }) => {
  const [selectedCells, setSelectedCells] = useState([]);
  const [currentWord, setCurrentWord] = useState('');
  const [isSelecting, setIsSelecting] = useState(false);
  const [cursorPosition, setCursorPosition] = useState({ x: 0, y: 0 });
  const [showCursorTrail, setShowCursorTrail] = useState(false);
  const [validationAnimation, setValidationAnimation] = useState(null);
  const gridRef = useRef(null);
  const containerRef = useRef(null);
  const cursorTrailRef = useRef([]);
  
  const { foundWords } = useGameStore();
  
  // Empêcher le scroll pendant le drag
  const preventScroll = useCallback((e) => {
    if (isSelecting) {
      e.preventDefault();
      e.stopPropagation();
      return false;
    }
  }, [isSelecting]);

  // Gestion du scroll
  useEffect(() => {
    if (isSelecting) {
      // Empêcher le scroll de la page
      document.body.style.overflow = 'hidden';
      document.body.style.touchAction = 'none';
      
      // Empêcher le scroll sur le conteneur
      if (containerRef.current) {
        containerRef.current.style.overflow = 'hidden';
      }
      
      // Écouteurs pour empêcher le scroll
      document.addEventListener('wheel', preventScroll, { passive: false });
      document.addEventListener('touchmove', preventScroll, { passive: false });
      document.addEventListener('scroll', preventScroll);
    }
    
    return () => {
      document.body.style.overflow = '';
      document.body.style.touchAction = '';
      
      if (containerRef.current) {
        containerRef.current.style.overflow = '';
      }
      
      document.removeEventListener('wheel', preventScroll);
      document.removeEventListener('touchmove', preventScroll);
      document.removeEventListener('scroll', preventScroll);
    };
  }, [isSelecting, preventScroll]);

  // Vérifie si deux cellules sont adjacentes
  const areCellsAdjacent = (cell1, cell2) => {
    const rowDiff = Math.abs(cell1.row - cell2.row);
    const colDiff = Math.abs(cell1.col - cell2.col);
    return rowDiff <= 1 && colDiff <= 1 && !(rowDiff === 0 && colDiff === 0);
  };

  // Vérifie si une cellule est déjà sélectionnée
  const isCellAlreadySelected = useCallback((row, col) => {
    return selectedCells.some(cell => cell.row === row && cell.col === col);
  }, [selectedCells]);

  // Trouve l'index de la dernière cellule sélectionnée
  const getLastSelectedCell = () => {
    return selectedCells.length > 0 ? selectedCells[selectedCells.length - 1] : null;
  };

  // Vérifie si le chemin vers une nouvelle cellule est valide
  const isValidPath = useCallback((newRow, newCol) => {
    if (selectedCells.length === 0) return true;
    
    const lastCell = getLastSelectedCell();
    if (!lastCell) return false;
    
    // Vérifie l'adjacence
    if (!areCellsAdjacent(lastCell, { row: newRow, col: newCol })) {
      return false;
    }
    
    // Vérifie si déjà sélectionnée
    if (isCellAlreadySelected(newRow, newCol)) {
      return false;
    }
    
    return true;
  }, [selectedCells, isCellAlreadySelected]);

  // Met à jour la position du curseur pour l'animation de drag
  const updateCursorPosition = (event) => {
    if (!gridRef.current || !isSelecting) return;
    
    const rect = gridRef.current.getBoundingClientRect();
    const x = event.clientX - rect.left;
    const y = event.clientY - rect.top;
    
    setCursorPosition({ x, y });
    
    // Ajoute la position au trail
    cursorTrailRef.current.push({ x, y, timestamp: Date.now() });
    
    // Garde seulement les dernières positions
    if (cursorTrailRef.current.length > 10) {
      cursorTrailRef.current.shift();
    }
  };

  // Handle mouse down on a cell
  const handleCellMouseDown = (letter, row, col, event) => {
    event.preventDefault();
    event.stopPropagation();
    setIsSelecting(true);
    setShowCursorTrail(true);
    setSelectedCells([{ letter, row, col }]);
    setCurrentWord(letter);
    
    // Initialise la position du curseur
    const rect = event.currentTarget.getBoundingClientRect();
    const x = rect.left + rect.width / 2;
    const y = rect.top + rect.height / 2;
    
    if (gridRef.current) {
      const gridRect = gridRef.current.getBoundingClientRect();
      setCursorPosition({
        x: x - gridRect.left,
        y: y - gridRect.top
      });
    }
  };

  // Handle mouse enter on a cell while dragging
  const handleCellMouseEnter = useCallback((letter, row, col, event) => {
    if (!isSelecting) return;
    
    event?.preventDefault();
    event?.stopPropagation();
    
    if (isValidPath(row, col)) {
      const newSelectedCells = [...selectedCells, { letter, row, col }];
      const newWord = newSelectedCells.map(cell => cell.letter).join('');
      
      setSelectedCells(newSelectedCells);
      setCurrentWord(newWord);
      
      // Met à jour la position du curseur au centre de la cellule
      if (event && event.currentTarget) {
        const rect = event.currentTarget.getBoundingClientRect();
        if (gridRef.current) {
          const gridRect = gridRef.current.getBoundingClientRect();
          setCursorPosition({
            x: rect.left + rect.width / 2 - gridRect.left,
            y: rect.top + rect.height / 2 - gridRect.top
          });
        }
      }
    }
  }, [isSelecting, selectedCells, isValidPath]);

  // Handle mouse move for cursor trail
  const handleMouseMove = (event) => {
    if (!isSelecting) return;
    updateCursorPosition(event);
  };

  // Handle touch move for drag selection
  const handleTouchMove = useCallback((event) => {
    if (!isSelecting) return;
    
    const touch = event.touches[0];
    if (!touch) return;
    
    // Update cursor position for trail
    if (gridRef.current) {
      const rect = gridRef.current.getBoundingClientRect();
      const x = touch.clientX - rect.left;
      const y = touch.clientY - rect.top;
      setCursorPosition({ x, y });
      
      // Add to trail
      cursorTrailRef.current.push({ x, y, timestamp: Date.now() });
      if (cursorTrailRef.current.length > 10) {
        cursorTrailRef.current.shift();
      }
    }
    
    // Find which cell the touch is over
    const element = document.elementFromPoint(touch.clientX, touch.clientY);
    if (element && element.dataset.row !== undefined && element.dataset.col !== undefined) {
      const row = parseInt(element.dataset.row);
      const col = parseInt(element.dataset.col);
      const letter = gridLetters[row][col];
      
      // Trigger cell selection if valid
      if (isValidPath(row, col)) {
        const newSelectedCells = [...selectedCells, { letter, row, col }];
        const newWord = newSelectedCells.map(cell => cell.letter).join('');
        setSelectedCells(newSelectedCells);
        setCurrentWord(newWord);
      }
    }
  }, [isSelecting, gridLetters, selectedCells, isValidPath]);

  // Handle mouse up - complete word selection
  const handleMouseUp = useCallback(() => {
    if (isSelecting && currentWord.length >= 3) {
      // Calculate center position of the word
      const gridRect = gridRef.current?.getBoundingClientRect();
      if (gridRect && selectedCells.length > 0) {
        const avgRow = selectedCells.reduce((sum, cell) => sum + cell.row, 0) / selectedCells.length;
        const avgCol = selectedCells.reduce((sum, cell) => sum + cell.col, 0) / selectedCells.length;
        
        const cellSize = gridRect.width / 5;
        const centerX = gridRect.left + (avgCol + 0.5) * cellSize;
        const centerY = gridRect.top + (avgRow + 0.5) * cellSize;
        
        const position = { x: centerX, y: centerY };
        const result = onWordFormed(currentWord, position);
        
        // Animate validation feedback
        if (result) {
          setValidationAnimation(result.success ? 'success' : 'error');
          setTimeout(() => setValidationAnimation(null), 600);
        }
      }
    }
    resetSelection();
  }, [isSelecting, currentWord, onWordFormed, selectedCells]);

  // Handle click on individual cell
  const handleCellClick = (letter, row, col) => {
    if (selectedCells.length === 0) {
      setSelectedCells([{ letter, row, col }]);
      setCurrentWord(letter);
      return;
    }

    if (isValidPath(row, col)) {
      const newSelectedCells = [...selectedCells, { letter, row, col }];
      const newWord = newSelectedCells.map(cell => cell.letter).join('');
      setSelectedCells(newSelectedCells);
      setCurrentWord(newWord);
    } else if (selectedCells.length === 1 && 
               selectedCells[0].row === row && 
               selectedCells[0].col === col) {
      resetSelection();
    }
  };

  // Reset selection
  const resetSelection = () => {
    setIsSelecting(false);
    setShowCursorTrail(false);
    setSelectedCells([]);
    setCurrentWord('');
    cursorTrailRef.current = [];
  };

  // Submit word
  const handleSubmitWord = () => {
    if (currentWord.length >= 3) {
      const gridRect = gridRef.current?.getBoundingClientRect();
      if (gridRect && selectedCells.length > 0) {
        const avgRow = selectedCells.reduce((sum, cell) => sum + cell.row, 0) / selectedCells.length;
        const avgCol = selectedCells.reduce((sum, cell) => sum + cell.col, 0) / selectedCells.length;
        
        const cellSize = gridRect.width / 5;
        const centerX = gridRect.left + (avgCol + 0.5) * cellSize;
        const centerY = gridRect.top + (avgRow + 0.5) * cellSize;
        
        const position = { x: centerX, y: centerY };
        const result = onWordFormed(currentWord, position);
        
        if (result) {
          setValidationAnimation(result.success ? 'success' : 'error');
          setTimeout(() => setValidationAnimation(null), 600);
        }
      }
      resetSelection();
    }
  };

  // Rendu de l'effet de trainée du curseur
  const renderCursorTrail = () => {
    if (!showCursorTrail || cursorTrailRef.current.length < 2) return null;

    const trailElements = [];
    const now = Date.now();
    
    // Filtre les positions récentes
    const recentPositions = cursorTrailRef.current.filter(
      pos => now - pos.timestamp < 200
    );

    for (let i = 0; i < recentPositions.length - 1; i++) {
      const currentPos = recentPositions[i];
      const nextPos = recentPositions[i + 1];
      
      const dx = nextPos.x - currentPos.x;
      const dy = nextPos.y - currentPos.y;
      const distance = Math.sqrt(dx * dx + dy * dy);
      const angle = Math.atan2(dy, dx) * 180 / Math.PI;
      
      const age = now - currentPos.timestamp;
      const opacity = Math.max(0, 1 - age / 200);
      
      trailElements.push(
        <motion.div
          key={`trail-${i}`}
          className="absolute"
          style={{
            left: currentPos.x,
            top: currentPos.y,
            width: distance,
            height: '4px',
            backgroundColor: `rgba(251, 191, 36, ${opacity * 0.5})`,
            transformOrigin: '0 50%',
            transform: `rotate(${angle}deg)`,
            zIndex: 30,
            borderRadius: '2px',
          }}
          initial={{ opacity: 0, scale: 0.5 }}
          animate={{ opacity: opacity, scale: 1 }}
          transition={{ duration: 0.1 }}
        />
      );
    }
    
    return trailElements;
  };

  // Rendu du curseur de drag
  const renderDragCursor = () => {
    if (!isSelecting || !cursorPosition) return null;

    return (
      <motion.div
        className="absolute pointer-events-none z-40"
        style={{
          left: cursorPosition.x,
          top: cursorPosition.y,
          width: '30px',
          height: '30px',
          borderRadius: '50%',
          backgroundColor: 'rgba(251, 191, 36, 0.3)',
          border: '2px solid #FBBF24',
          transform: 'translate(-50%, -50%)',
        }}
        animate={{
          scale: [1, 1.2, 1],
        }}
        transition={{
          duration: 1,
          repeat: Infinity,
          ease: "easeInOut"
        }}
      >
        <div
          className="absolute top-1/2 left-1/2 w-2 h-2 bg-yellow-400 rounded-full transform -translate-x-1/2 -translate-y-1/2"
        />
      </motion.div>
    );
  };

  // Global mouse up listener
  useEffect(() => {
    const handleGlobalMouseUp = () => {
      handleMouseUp();
    };

    document.addEventListener('mouseup', handleGlobalMouseUp);
    document.addEventListener('touchend', handleGlobalMouseUp);
    
    return () => {
      document.removeEventListener('mouseup', handleGlobalMouseUp);
      document.removeEventListener('touchend', handleGlobalMouseUp);
    };
  }, [handleMouseUp]);

  // Écouteur pour le mouvement global de la souris
  useEffect(() => {
    const handleGlobalMouseMove = (event) => {
      handleMouseMove(event);
    };

    if (isSelecting) {
      document.addEventListener('mousemove', handleGlobalMouseMove);
    }

    return () => {
      document.removeEventListener('mousemove', handleGlobalMouseMove);
    };
  }, [isSelecting]);

  // Nettoyage au démontage
  useEffect(() => {
    return () => {
      document.body.style.overflow = '';
      document.body.style.touchAction = '';
    };
  }, []);

  return (
    <div 
      ref={containerRef}
      className="fixed top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 flex flex-col items-center gap-5 z-50 bg-gradient-to-br from-white/95 to-gray-100/95 rounded-2xl p-6 shadow-2xl backdrop-blur-sm max-h-[90vh] w-auto min-w-[350px] max-w-[95vw] overflow-hidden"
    >
      {/* Animation de validation */}
      {validationAnimation && (
        <motion.div
          className={`absolute inset-0 flex items-center justify-center z-50 ${
            validationAnimation === 'success' ? 'bg-green-500/20' : 'bg-red-500/20'
          } backdrop-blur-sm`}
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          exit={{ opacity: 0 }}
        >
          <motion.div
            className={`p-4 rounded-full ${
              validationAnimation === 'success' 
                ? 'bg-green-500 text-white' 
                : 'bg-red-500 text-white'
            }`}
            initial={{ scale: 0 }}
            animate={{ scale: 1 }}
            transition={{ type: "spring", stiffness: 200, damping: 15 }}
          >
            {validationAnimation === 'success' ? (
              <Check className="w-12 h-12" />
            ) : (
              <X className="w-12 h-12" />
            )}
          </motion.div>
        </motion.div>
      )}

      {/* Affichage du mot actuel */}
      {currentWord && (
        <motion.div 
          className="text-3xl font-bold text-gray-800 text-center px-6 py-3 bg-gradient-to-r from-yellow-400 to-orange-400 rounded-xl shadow-lg min-w-[250px]"
          initial={{ opacity: 0, y: -20 }}
          animate={{ opacity: 1, y: 0 }}
          exit={{ opacity: 0, y: -20 }}
        >
          {currentWord.toUpperCase()}
          <span className="text-xl text-gray-700/80 ml-2">
            ({currentWord.length})
          </span>
        </motion.div>
      )}
      
      {/* Conteneur de la grille */}
      <div 
        ref={gridRef}
        className="relative bg-white/80 rounded-xl p-5 shadow-lg overflow-hidden"
        onMouseLeave={() => {
          if (isSelecting) {
            handleMouseUp();
          }
        }}
      >
        {/* Zone de trainée du curseur */}
        <div className="absolute inset-0 pointer-events-none z-30 overflow-hidden">
          {renderCursorTrail()}
        </div>
        
        {/* Curseur de drag */}
        {renderDragCursor()}
        
        {/* Grille de lettres */}
        <div className="relative flex flex-col gap-2 touch-none">
          {gridLetters.map((row, rowIndex) => (
            <div key={rowIndex} className="flex gap-2">
              {row.map((letter, colIndex) => {
                const isSelected = isCellAlreadySelected(rowIndex, colIndex);
                const selectionIndex = selectedCells.findIndex(
                  cell => cell.row === rowIndex && cell.col === colIndex
                );
                
                return (
                  <motion.div
                    key={`${rowIndex}-${colIndex}`}
                    className={`
                      relative w-14 h-14 md:w-16 md:h-16 flex items-center justify-center 
                      text-2xl md:text-3xl font-bold rounded-xl cursor-pointer 
                      select-none shadow-md transition-all duration-150
                      ${isSelected 
                        ? 'bg-yellow-400 text-gray-800 shadow-lg shadow-yellow-400/30 z-20' 
                        : 'bg-white text-gray-700 hover:bg-yellow-100'
                      }
                    `}
                    onMouseDown={(e) => handleCellMouseDown(letter, rowIndex, colIndex, e)}
                    onTouchStart={(e) => {
                      e.preventDefault();
                      e.stopPropagation();
                      handleCellMouseDown(letter, rowIndex, colIndex, e);
                    }}
                    onMouseEnter={(e) => handleCellMouseEnter(letter, rowIndex, colIndex, e)}
                    onTouchMove={(e) => handleTouchMove(e)}
                    onClick={() => handleCellClick(letter, rowIndex, colIndex)}
                    data-row={rowIndex}
                    data-col={colIndex}
                    whileHover={{ scale: 1.05 }}
                    whileTap={{ scale: 0.95 }}
                    animate={{
                      scale: isSelected ? 1.1 : 1,
                    }}
                  >
                    {letter}
                    
                    {/* Numéro d'ordre de sélection */}
                    {isSelected && (
                      <motion.div 
                        className="absolute bottom-1 right-1 text-xs font-bold text-gray-800 bg-white/90 w-5 h-5 rounded-full flex items-center justify-center"
                        initial={{ scale: 0 }}
                        animate={{ scale: 1 }}
                      >
                        {selectionIndex + 1}
                      </motion.div>
                    )}
                    
                    {/* Indicateur de début de sélection */}
                    {isSelected && selectionIndex === 0 && (
                      <motion.div
                        className="absolute -top-1 -right-1 w-3 h-3 bg-yellow-500 rounded-full"
                        animate={{ scale: [1, 1.5, 1] }}
                        transition={{ duration: 1, repeat: Infinity }}
                      />
                    )}
                  </motion.div>
                );
              })}
            </div>
          ))}
        </div>
        
        {/* Instructions */}
        <div className="mt-4 text-center text-sm text-gray-600">
          <p>Glissez pour sélectionner les lettres adjacentes</p>
          <p className="text-xs text-gray-500">(minimum 3 lettres)</p>
        </div>
      </div>
      
      {/* Contrôles */}
      <div className="flex gap-4 mt-4">
        <motion.button 
          className={`
            flex items-center gap-2 px-6 py-3 font-semibold rounded-xl
            transition-all duration-200 shadow-md
            ${currentWord.length > 0
              ? 'bg-gray-200 text-gray-700 hover:bg-gray-300'
              : 'bg-gray-100 text-gray-400 cursor-not-allowed'
            }
          `}
          onClick={resetSelection}
          whileHover={{ scale: currentWord.length > 0 ? 1.05 : 1 }}
          whileTap={{ scale: currentWord.length > 0 ? 0.95 : 1 }}
          disabled={currentWord.length === 0}
        >
          <RotateCcw className="w-5 h-5" />
          Effacer
        </motion.button>
        
        <motion.button 
          className={`
            flex items-center gap-2 px-6 py-3 font-semibold rounded-xl
            transition-all duration-200 shadow-md
            ${currentWord.length >= 3
              ? 'bg-gradient-to-r from-green-500 to-emerald-500 text-white hover:from-green-600 hover:to-emerald-600'
              : 'bg-gray-300 text-gray-500 cursor-not-allowed'
            }
          `}
          onClick={handleSubmitWord}
          disabled={currentWord.length < 3}
          whileHover={{ scale: currentWord.length >= 3 ? 1.05 : 1 }}
          whileTap={{ scale: currentWord.length >= 3 ? 0.95 : 1 }}
        >
          <Check className="w-5 h-5" />
          Valider 
          <span className="ml-1 bg-white/20 px-2 py-1 rounded-lg">
            ({currentWord.length})
          </span>
        </motion.button>
      </div>
      
      {/* Indicateur de drag en cours */}
      {isSelecting && (
        <motion.div
          className="absolute -top-3 right-4 bg-yellow-500 text-white text-xs font-bold px-3 py-1 rounded-full"
          initial={{ y: -10, opacity: 0 }}
          animate={{ y: 0, opacity: 1 }}
        >
          <div className="flex items-center gap-1">
            <Zap className="w-3 h-3" />
            Glissement en cours
          </div>
        </motion.div>
      )}
    </div>
  );
};

export default LetterGrid;